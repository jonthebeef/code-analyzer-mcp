import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join, resolve } from 'path';

/**
 * Manages markdown file operations for agent reports and coordination.
 * Handles creation, reading, writing, and parsing of markdown files used by agents.
 * 
 * @class MarkdownManager
 * @example
 * const filePath = MarkdownManager.createWorkingFile('security', '/path/to/repo');
 * const comments = MarkdownManager.parseComments(content);
 */
export class MarkdownManager {
  /**
   * Creates a working markdown file for an agent with initial structure.
   * 
   * @param {string} agentName - Name of the agent (e.g., 'security', 'code-quality')
   * @param {string} repoPath - Path to the repository being analyzed
   * @param {string} [outputDir='output'] - Directory to create the file in
   * @returns {string} The path to the created file
   * @throws {Error} If agentName contains invalid characters or attempts path traversal
   * @example
   * const filePath = MarkdownManager.createWorkingFile('api-quality', './my-repo', './reports');
   */
  static createWorkingFile(agentName, repoPath, outputDir = 'output') {
    // Sanitize agent name to prevent path traversal attacks
    const sanitizedAgentName = this.sanitizeAgentName(agentName);
    const fileName = `${sanitizedAgentName}-analysis.md`;
    const filePath = this.secureJoin(outputDir, fileName);
    
    const initialContent = `# ${agentName.charAt(0).toUpperCase() + agentName.slice(1)} Analysis

Repository: ${repoPath}
Started: ${new Date().toISOString()}

## Analysis Results

_Analysis in progress..._

## Coordination

_Coordination comments will appear here_

---
*Generated by Code Analyzer*
`;

    writeFileSync(filePath, initialContent, 'utf8');
    return filePath;
  }

  static readFile(filePath) {
    if (!existsSync(filePath)) {
      return '';
    }
    return readFileSync(filePath, 'utf8');
  }

  static writeFile(filePath, content) {
    writeFileSync(filePath, content, 'utf8');
  }

  static parseComments(content) {
    // Allow hyphens in agent names with [\w-]+
    const commentRegex = /<!-- @([\w-]+): ([^\n]+)\nContext: ([^\n]+)\nStatus: (pending|resolved)\nRound: (\d+)\n-->/g;
    const comments = [];
    
    // Use matchAll to get all matches at once, avoiding global regex state issues
    const matches = Array.from(content.matchAll(commentRegex));
    
    for (let i = 0; i < matches.length; i++) {
      const match = matches[i];
      comments.push({
        id: `comment-${i + 1}`,
        targetAgent: match[1],
        question: match[2],
        context: match[3],
        status: match[4],
        round: parseInt(match[5]),
        fullMatch: match[0]
      });
    }

    return comments;
  }

  static addComment(filePath, targetAgent, question, context, round = 1) {
    const content = this.readFile(filePath);
    const comment = `<!-- @${targetAgent}: ${question}
Context: ${context}
Status: pending
Round: ${round}
-->

`;

    const coordinationIndex = content.indexOf('## Coordination');
    if (coordinationIndex === -1) {
      return false;
    }

    const beforeCoordination = content.substring(0, coordinationIndex + '## Coordination'.length);
    const afterCoordination = content.substring(coordinationIndex + '## Coordination'.length);
    
    const newContent = beforeCoordination + '\n\n' + comment + afterCoordination;
    this.writeFile(filePath, newContent);
    return true;
  }

  static markResolved(filePath, commentId) {
    let content = this.readFile(filePath);
    const comments = this.parseComments(content);
    
    const comment = comments.find(c => c.id === commentId);
    if (!comment) {
      return false;
    }

    const resolvedComment = comment.fullMatch.replace('Status: pending', 'Status: resolved');
    content = content.replace(comment.fullMatch, resolvedComment);
    
    this.writeFile(filePath, content);
    return true;
  }

  static respondToComment(filePath, commentId, response) {
    let content = this.readFile(filePath);
    const comments = this.parseComments(content);
    
    const comment = comments.find(c => c.id === commentId);
    if (!comment) {
      return false;
    }

    const responseText = `\n**Response:** ${response}\n`;
    const updatedComment = comment.fullMatch
      .replace('Status: pending', 'Status: resolved')
      .replace('-->', responseText + '-->');
    content = content.replace(comment.fullMatch, updatedComment);
    
    this.writeFile(filePath, content);
    return true;
  }

  /**
   * Sanitizes agent name to prevent path traversal and injection attacks.
   * 
   * @param {string} agentName - The agent name to sanitize
   * @returns {string} Sanitized agent name
   * @throws {Error} If agentName is invalid or contains dangerous characters
   * @private
   */
  static sanitizeAgentName(agentName) {
    if (!agentName || typeof agentName !== 'string') {
      throw new Error('Agent name must be a non-empty string');
    }

    // Remove leading/trailing whitespace
    const trimmed = agentName.trim();

    if (trimmed.length === 0) {
      throw new Error('Agent name cannot be empty or whitespace only');
    }

    // Check for path traversal attempts
    if (trimmed.includes('..') || trimmed.includes('/') || trimmed.includes('\\')) {
      throw new Error('Agent name contains invalid path characters');
    }

    // Check for control characters and null bytes
    if (/[\x00-\x1F\x7F]/.test(trimmed)) {
      throw new Error('Agent name contains invalid control characters');
    }

    // Whitelist validation: allow only alphanumeric, hyphens, and underscores
    if (!/^[a-zA-Z0-9_-]+$/.test(trimmed)) {
      throw new Error('Agent name can only contain letters, numbers, hyphens, and underscores');
    }

    // Length validation
    if (trimmed.length > 50) {
      throw new Error('Agent name must not exceed 50 characters');
    }

    return trimmed;
  }

  /**
   * Securely joins paths while preventing directory traversal attacks.
   * 
   * @param {string} outputDir - Base output directory
   * @param {string} fileName - File name to join
   * @returns {string} Secure joined path
   * @throws {Error} If the resulting path attempts to escape the output directory
   * @private
   */
  static secureJoin(outputDir, fileName) {
    if (!outputDir || typeof outputDir !== 'string') {
      throw new Error('Output directory must be a non-empty string');
    }

    if (!fileName || typeof fileName !== 'string') {
      throw new Error('File name must be a non-empty string');
    }

    // Normalize path separators and check for traversal attempts
    const normalizedFileName = fileName.replace(/\\/g, '/');
    if (normalizedFileName.includes('../') || normalizedFileName.includes('./..')) {
      throw new Error('File path attempts to escape output directory');
    }

    // Resolve the output directory to get absolute path
    const resolvedOutputDir = resolve(outputDir);
    
    // Join the paths
    const candidatePath = join(resolvedOutputDir, fileName);
    
    // Resolve to get the absolute path and normalize
    const resolvedPath = resolve(candidatePath);
    
    // Ensure the resolved path is within the output directory (cross-platform check)
    const normalizedOutputDir = resolvedOutputDir.replace(/\\/g, '/');
    const normalizedResolvedPath = resolvedPath.replace(/\\/g, '/');
    
    if (!normalizedResolvedPath.startsWith(normalizedOutputDir + '/') && normalizedResolvedPath !== normalizedOutputDir) {
      throw new Error('File path attempts to escape output directory');
    }

    return candidatePath;
  }
}